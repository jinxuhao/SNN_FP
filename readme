在本地 拉取这个特定的 CUDA 镜像：

docker pull nvidia/cuda:11.8.0-devel-ubuntu20.04

行以下命令验证镜像是否正确配置：

docker run --gpus all nvidia/cuda:11.8.0-base-ubuntu20.04 nvidia-smi


pip3 install numpy==1.24.3 scipy==1.10.1


使用两遍
pip install "numpy<2.0"


netifaces报错
python3 -m pip install netifaces --upgrade --user
sudo apt install ros-noetic-desktop-full


bug:
Traceback (most recent call last):
    File "/workspace/src/snn_pid_controller/scripts/snn_P_layer_2.py", line 8, in <module>
      from bindsnet.network.nodes import Neurons
  ImportError: cannot import name 'Neurons' from 'bindsnet.network.nodes' (/home/developer/.local/lib/python3.9/site-packages/bindsnet/network/nodes.py)

  在较新的 BindsNET 版本中，Neurons 类可能已经更改或被替换。我们可以改用 LIFNodes（LIF 表示泄漏积分-发放神经元），这在 BindsNET 中通常用作神经元层的实现



  从 SNN 的角度来看，这种结构已经实现了一个初步的控制器功能，但并不算是一个完整的 SNN 网络。在传统的 SNN 网络中，通常还包括：

隐藏层或中间层：用于处理输入信号并生成特征模式，增加网络的复杂性和表现力。
多层神经元连接：通常会有层与层之间的连接（突触）来传播和调制信号。
学习机制：在完整的 SNN 网络中，通常会包含基于突触可塑性的学习机制，如 STDP（Spike-Timing-Dependent Plasticity），使网络能自适应地调整连接强度。
当前结构的局限性
目前的结构较为简单，主要使用了一些固定的计算和参数，而没有实现复杂的神经元间连接和学习机制。因此，它可以算作一个初步的、模拟 SNN 控制行为的控制器框架，但并未完全反映一个完整的 SNN 网络的动态特性和自适应能力。

如何完善
如果希望进一步扩展为一个完整的 SNN，可以考虑：

增加隐藏层：在误差和输出之间引入更多的神经层，增加系统的非线性响应特性。
加入学习规则：实现突触可塑性，允许网络在运行过程中根据误差信号动态调整连接权重。
强化神经元之间的连接：在不同层之间建立突触连接，以便信号在层与层之间传递，并逐渐形成复杂的模式。



  从输出信息来看，即使 `shift_up` 被触发，`I_population` 的激活位置依然没有变化。问题可能在于 `self.shift_up.v` 中的值没有正确地传递到 `update_integral_population` 方法，或者 `update_integral_population` 的逻辑无法有效改变 `I_population` 的激活状态。

为了进一步诊断和确保 `shift_up` 的触发确实改变了 `I_population` 的状态，可以对代码进行如下调整：

1. **直接在 `integrate_error` 中手动调用 `update_integral_population`**，而不依赖 `shift_up.v` 和 `shift_down.v`。
2. **在触发 `shift_up` 或 `shift_down` 时，立即更新 `I_population` 的激活状态**。

### 代码修改：直接调用 `update_integral_population`

在触发 `shift_up` 和 `shift_down` 时，不依赖 `shift_up.v` 和 `shift_down.v`，而是直接手动更新 `I_population` 的激活位置。

#### 更新 `integrate_error` 方法

```python
def integrate_error(self, error_signal):
    """
    根据误差信号更新积分层的状态。
    error_signal: 输入的误差值，正值增加 c_plus 的电位，负值增加 c_minus 的电位。
    """
    if error_signal > 0:
        self.c_plus.v[0] += error_signal  # 累积正误差信号
        print(f"c_plus.v: {self.c_plus.v[0].item()}")
    elif error_signal < 0:
        self.c_minus.v[0] += abs(error_signal)  # 累积负误差信号
        print(f"c_minus.v: {self.c_minus.v[0].item()}")

    # 检查是否达到阈值并触发 shift 位置的移动
    if self.c_plus.v[0].item() >= self.threshold:
        self.c_plus.v[0] = 0  # 重置 c_plus
        self.update_integral_population("up")  # 直接更新 I_population 向上移动
        print("c_plus.v 达到阈值，触发 shift_up")

    if self.c_minus.v[0].item() >= self.threshold:
        self.c_minus.v[0] = 0  # 重置 c_minus
        self.update_integral_population("down")  # 直接更新 I_population 向下移动
        print("c_minus.v 达到阈值，触发 shift_down")
```

#### 修改 `update_integral_population` 方法

将 `update_integral_population` 修改为接受参数 `direction`，从而决定是否执行向上或向下的激活位置移动。

```python
def update_integral_population(self, direction):
    """根据给定的方向更新 I_population 的状态"""
    # 获取当前激活的位置
    active_index = torch.argmax(self.I_population.v).item()
    print(f"Current active index in I_population: {active_index}")
    
    if direction == "up" and active_index < self.num_neurons - 1:
        # 向上移动激活位置，确保不越界
        self.I_population.v[active_index] = 0  # 清除当前激活
        self.I_population.v[active_index + 1] = 1  # 激活上一个神经元
        print(f"Shift up activated: moved active index to {active_index + 1}")
        
    elif direction == "down" and active_index > 0:
        # 向下移动激活位置，确保不越界
        self.I_population.v[active_index] = 0  # 清除当前激活
        self.I_population.v[active_index - 1] = 1  # 激活下一个神经元
        print(f"Shift down activated: moved active index to {active_index - 1}")
    
    # 输出 I_population 的状态以调试
    print("Updated I_population state:", self.I_population.v)
```

### 说明

1. **直接调用 `update_integral_population`**：在 `integrate_error` 中达到阈值时，直接调用 `update_integral_population`，并指定方向。
2. **消除对 `shift_up.v` 和 `shift_down.v` 的依赖**：通过指定 `direction` 参数，直接更新 `I_population`。

### 运行测试

重新运行 `main.py`，观察 `Integral state` 是否能够随着时间步更新。此修改确保在达到阈值时，`I_population` 中的激活状态会立即更新，不再依赖 `shift_up` 和 `shift_down` 的状态。